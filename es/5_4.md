## 1.7  → 5.4

* filter 取消，与 query 合并
* string 弃用，细分为 keyword 和 text
* aggregation 缓存支持
* 新增 profile api

## 
* 选择合适的路由和分片
* 使用 filter 替代 query
* 枚举字段类型的选择
* 聚合查询的优化
* multiquery 方法实现


Lucene 6.0 索引变动

数值类型存储使用block k-d tree，不再使用倒排索引。
Scorer 
遍历所有匹配的文档，并为每个文档生成得分的机制。

为所有匹配的doc id 生成一个迭代器。
主要的时间在type和status查询阶段，pid和appid查询时间也有点长，且主要时间都是在build_scorer阶段。原因是Lucene改进了数值类型的索引数据结构，使用了block k-d 树。这种树的叶结点上文档不是有序排列的，所以查询的时候需要获取所有的文档id，访问 docValues构造 bitset，进行其它条件的联合查询。当查询的结果集很大的时候，大量时间会用于构造bitset，导致了慢查询。

解决方式：在不需要进行 rangeQuery 的时候，尽量不要选择数值类型作为存储格式，使用 keyword 替代，尤其是在重复值数量很大的时候。

https://elasticsearch.cn/article/446

Lucene从6.0开始引入了Block k-d tree来重新设计数值类型的索引结构，其目标是让数值型数据索引的结构更紧凑，搜索速度更快。这种数据结构是为多维数值字段设计的，可以高效的用于诸如地理位置这类数据的快速过滤，但同样适用于单维度的数值型。

