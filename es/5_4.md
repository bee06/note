## 1.7  → 5.4

* filter 取消，与 query 合并
* string 弃用，细分为 keyword 和 text
* aggregation 缓存支持
* 新增 profile api

## 
* 选择合适的路由和分片
* 使用 filter 替代 query
* 枚举字段类型的选择
* 聚合查询的优化
* multiquery 方法实现


Lucene 6.0 索引变动

数值类型存储使用block k-d tree，不再使用倒排索引。
Scorer 
遍历所有匹配的文档，并为每个文档生成得分的机制。

为所有匹配的doc id 生成一个迭代器。
主要的时间在type和status查询阶段，pid和appid查询时间也有点长，且主要时间都是在build_scorer阶段。原因是Lucene改进了数值类型的索引数据结构，使用了block k-d 树。这种树的叶结点上文档不是有序排列的，所以查询的时候需要获取所有的文档id，访问 docValues构造 bitset，进行其它条件的联合查询。当查询的结果集很大的时候，大量时间会用于构造bitset，导致了慢查询。

解决方式：在不需要进行 rangeQuery 的时候，尽量不要选择数值类型作为存储格式，使用 keyword 替代，尤其是在重复值数量很大的时候。

https://elasticsearch.cn/article/446

Lucene从6.0开始引入了Block k-d tree来重新设计数值类型的索引结构，其目标是让数值型数据索引的结构更紧凑，搜索速度更快。这种数据结构是为多维数值字段设计的，可以高效的用于诸如地理位置这类数据的快速过滤，但同样适用于单维度的数值型。

## filter/query 
过滤查询（filter）是对集合包含/排除的简单检查，这使得它们计算速度非常快。 当至少有一个过滤查询是“稀疏”（仅有少量匹配的文档）时，可以利用各种优化，并且可以将缓存经常使用的filter过滤查询缓存在内存中以加快访问速度。

对比之下，query检索(评分查询)不仅要查找匹配的文档，还要计算每个文档的相关程度，这通常会使其比非评分文档更复杂。 另外，查询结果不可缓存。

由于倒排索引，只有几个文档匹配的简单评分查询（query检索）可能会比跨越数百万个文档的过滤器（filter过滤）表现得更好。 但是，一般来说，fiter过滤的性能将胜过评分查询（query检索）。

过滤（filter）的目标是减少必须由评分查询（query）检查的文档数量。
