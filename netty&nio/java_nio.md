## 标准I/O存在问题
### 数据多次拷贝
标准I/O处理，完成一次完整的数据读写，至少需要从底层硬件读到内核空间，再读到用户文件，又从用户空间写入内核空间，再写入底层硬件

此外，底层通过write、read等函数进行I/O系统调用时，需要传入数据所在缓冲区起始地址和长度由于JVM GC的存在，导致对象在堆中的位置往往会发生移动，移动后传入系统函数的地址参数就不是真正的缓冲区地址了

可能导致读写出错，为了解决上面的问题，使用标准I/O进行系统调用时，还会额外导致一次数据拷贝：把数据从JVM的堆内拷贝到堆外的连续空间内存(堆外内存)
### 操作阻塞
传统的网络I/O处理中，由于请求建立连接(connect)，读取网络I/O数据(read)，发送数据(send)等操作是线程阻塞的


## 零拷贝
基本流程如下：

(1) 用户进程发起sendfile系统调用
(2) 内核基于DMA Copy将文件数据从磁盘拷贝到内核缓冲区
(3) 内核将内核缓冲区中的文件描述信息(文件描述符，数据长度)拷贝到Socket缓冲区
(4) 内核基于Socket缓冲区中的文件描述信息和DMA硬件提供的Gather Copy功能将内核缓冲区数据复制到网卡
(5) 用户进程sendfile系统调用完成并返回


mmap + write 实现零拷贝的基本流程如下：

(1) 用户进程向内核发起系统mmap调用
(2) 将用户进程的内核空间的读缓冲区与用户空间的缓存区进行内存地址映射
(3) 内核基于DMA Copy将文件数据从磁盘复制到内核缓冲区
(4) 用户进程mmap系统调用完成并返回
(5) 用户进程向内核发起write系统调用
(6) 内核基于CPU Copy将数据从内核缓冲区拷贝到Socket缓冲区
(7) 内核基于DMA Copy将数据从Socket缓冲区拷贝到网卡
(8) 用户进程write系统调用完成并返回