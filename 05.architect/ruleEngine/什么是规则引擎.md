# 前言
让我们从问题开始。假设告诉你构建一个银行应用程序，实现如下所述的逻辑。

> 如果一个人的月薪超过70K并且信用评分超过900，则有资格申请汽车贷款，然后批准汽车贷款并核准所请求金额的60％。

在应用程序中轻松实现这些类型的规则或逻辑。但是如果增加一些额外的要求，比如：
* 如果有大量的逻辑，那么你如何保证良好的性能
* 如果逻辑经常变化，那么你如何管理或更改频繁的代码呢？避免频繁部署。
* 设计应用程序，使业务人员可以轻松维护和理解它。 （供非技术人员使用）
* 如果你必须将所有业务逻辑集中存放并与所有应用程序分开，则你会把它放在哪里？

为了在我们的应用程序中实现所有这些要求，我们可以使用规则引擎。但在启动规则引擎之前，让我们了解一些术语和背景知识。

# 名词解释
规则：它是一组条件，后面跟着一组动作。它代表了系统的逻辑。规则主要以 if-then 形式表示。它主要包含两个部分，条件和动作。该规则也称为生产。

> Rule = Condition + Action
该条件也被称为事实、前提。而行动也被称为结果。
* 人类专家：是相应业务领域专家的人。这个人以规则的形式提供知识。例如，上述汽车贷款的逻辑是由银行专家提供的
规则形式的知识：
```
Rule 1: A person is eligible for car loan?
if:
   1. He has monthly salary more than 70K.
   2. His credit score is more than 900.
then:
   1. Approved car loan.
   2. Sanctioned 60% of requested car loan amount.
Rule 2: A person is eligible for car loan?
if:
   1. He has monthly salary more than 35K.
   2. His credit score is more than 700.
then:
   1. Approved car loan.
   2. Sanctioned 90% of requested car loan amount.
```

* 专家系统：这是一个利用人类专家的知识来解决问题并给出解决方案的程序。它也被称为基于规则的系统或生产系统。
  
!(1_Soehprv)[../1_Soehprv-GYv3wghqnc49Nw.webp]

* 推理机：是专家系统的大脑，管理着专家系统内部的大量规则和事实。它的工作是选择规则并应用于数据并生成解决方案。我们将详细讨论它。

现在让我们尝试了解规则引擎。

# 规则引擎

它是一个专家系统程序，它对数据运行规则，如果任何条件匹配，它就会执行相应的操作。

图1

在上图中，
* 它表明以规则的形式（if-then 形式）收集知识并将它们存储在任何存储中。
* 规则可以存储在任何存储中，如文件或数据库。
* 现在推理引擎根据要求选择规则并在输入数据。
* 如果任何模式/条件匹配，则它执行相应的操作并返回结果或解决方案。


# 推理引擎
* 推理引擎是人工智能中智能系统的组成部分，它将逻辑规则应用于知识库，从已知事实中推断出新信息。第一个推理机是专家系统的一部分。推理机通常以两种模式进行，它们是：
  * 正向推理
  * 反向推理

推理引擎的程序分三个阶段对给定数据执行规则。

* 阶段 1 — 匹配：在此阶段，推理引擎将事实和数据与规则集进行匹配。这个过程称为模式匹配。

我们可以用于模式匹配的算法是：
* Linear 算法
* Rete 算法
* Treat 算法
* Leaps 算法

Drools 是规则引擎的实现之一，使用 Rete 算法进行模式匹配。它是模式匹配的最佳算法之一。

第一阶段的输出是一个冲突集。冲突集意味着对于相同的事实或条件，可能有多个规则被满足。因此它返回了冲突规则的集合。

* 阶段 2 — 解决：在此阶段，推理引擎管理冲突规则的顺序。它解决了冲突并给出了选定的规则。为了解决冲突，它可以使用以下任何算法。
  * Lex
  * Recency
  * MEA
  * Refactor
  * Priority wise

* 阶段 3 — 执行：在此阶段，推理引擎仅对给定数据运行所选规则的操作，并将输出/结果返回给客户端。

## 推理方法：
规则引擎通常使用以下推理方法之一来实现推理引擎。
* Forward chaining
* Backward chaining

但在了解推理方法之前，我们先了解一下推理。有两种类型的推理。

1. 目标导向/反向推理：它是从目标开始逆向推理。在这里，我们从主要目标开始，然后再去寻找子目标。所以在目标导向推理中，如果我们要实现主要目标，那么我们必须思考“要实现主要目标，我们必须实现哪些子目标”。

示例：如果我们计划晚上外出，为此，我们计划去看电影、郊游和晚餐。然后晚上出去是我们的主要目标，电影、郊游和晚餐是主要目标的子目标。

2. 数据驱动/正向推理：它从可用数据开始，使用规则提取更多数据，直到达到目标。在这里我们查看数据，如果我们发现某种模式，那么它会执行相应的操作。

示例：假设我们必须根据给定的规则和数据计算出名为 Fritz 的宠物的颜色。

Rules:
```
If X croaks and X eats flies - Then X is a frog
2. If X chirps and X sings - Then X is a canary
3. If X is a frog - Then X is green
4. If X is a canary - Then X is yellow
```

Data:

```
1. Fritz croaks
2. Fritz eats flies
```

这里使用给定的规则和数据，我们可以提取更多数据，例如：

```
Fritz is a frog.
Fritz is green.
```
### 正向推理
那么现在让我们讨论推理方法
* 它是前向推理的一个实现。
* 它是数据驱动的。
* 事实断言进入工作内存
* 一个或多个规则可以同时为真。

### 反向推理：
* 它是反向推理的一种实现。
* 它是目标驱动的
* 从结论（目标）开始，如果找不到则搜索子目标。
* 还有一类称为混合链接。流口水使用它。它是前向链接和后向链接的组合。

# 规则引擎的优势
* 我们可以将给出的示例中的上述所有特定要求视为规则引擎的优势。
  * 任何非技术人员（如业务分析师、客户团队等）都非常容易阅读和编写规则。在这里，您必须关注“做什么”，而不是“怎么做”。
  * 您将所有规则存储在中心存储中。这意味着您拥有所有业务规则和逻辑所在的中心位置。它将成为你的真理之源。
  * 逻辑与核心应用程序逻辑分开管理，因此可以对其进行管理和重用。
  * 在规则引擎中，我们使用不同的模式匹配和冲突解决算法，从而提供高性能。
  * 对于频繁变化的需求，我们可以轻松更新规则。无需更改代码。
  * 如果代码包含许多决策点，则代码的复杂性会更高。规则引擎可以更好地处理它，因为它们使用一致的业务规则表示。
  * 不同的应用程序可以对相同的逻辑使用相同的规则引擎。它增加了可重用性。
  
# 规则引擎的实现
* 有许多可用于规则引擎的实现。很少有人像：
  * Drools：Drools 是一种业务规则管理系统 (BRMS) 解决方案。它是面向对象的 Java 规则引擎。
  * JRule ：JRuleEngine 是基于 Java Specification Request 94 的 java 规则引擎
  * EasyRules：Easy Rules 是一个 Java 规则引擎，灵感来自一篇名为“我应该使用规则引擎吗？”的文章。 ”的马丁·福勒。
