## 同步阻塞网络IO
### 介绍
简称BIO
```
int main()
{
 int sk = socket(AF_INET, SOCK_STREAM, 0);
 connect(sk, ...)
 recv(sk, ...)
}
```
1.进程在 recv 的时候大概率会被阻塞掉，导致一次进程切换
2.当连接上数据就绪的时候进程又会被唤醒，又是一次进程切换
3.一个进程同时只能等待一条连接，如果有很多并发，则需要很多进程

## 


## 问题
1. linux操作系统，提供了三种网络编程模型  select poll epoll,
   1. 这三种模型都可以用来实现 I/O 多路复用，即同时监听多个文件描述符，以确定是否有数据可读写。它们都是基于事件驱动的编程模型，能够提高程序的并发性和性能。

下面简要介绍一下这三种模型的特点：
select：是最古老的一种 I/O 多路复用模型，也是最常用的一种。它使用 fd_set 类型的数据结构来管理文件描述符集合，可以同时监听多个文件描述符的可读可写事件。但是，由于它使用的数据结构有一定的限制，每次调用 select 函数时需要重新初始化 fd_set 结构体，导致效率不够高。
poll：是对 select 模型的改进，使用一个数组来管理文件描述符，可以同时监听更多的文件描述符。poll 的另一个优点是支持 edge-triggered 和 level-triggered 两种事件触发方式。但是，当文件描述符数量较大时，效率也不高。
epoll：是最新的一种 I/O 多路复用模型，是在 Linux 内核 2.6 版本中引入的。它使用红黑树和双向链表来管理文件描述符，可以同时监听大量文件描述符的可读可写事件，并且效率非常高。epoll 也支持 edge-triggered 和 level-triggered 两种事件触发方式。因此，epoll 是目前最常用的一种 I/O 多路复用模型。

2. 他们之间的有什么关系，各自优缺点
3. redis、nginx为什么采用epoll
4. 