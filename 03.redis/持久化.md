## AOF

### 流程
* 先执行命令，在记录AOF日志
* 命令执行后才记录日志，不会阻塞当前的写操作

### 风险
* 如果命令执行完，还没有来的及记录日志就宕机了，那么这个命令和相应的数据就丢失了
* AOF虽然避免了对当前命令的阻塞，可能会给下一个操作带来阻塞风险，因为,AOF日志也是主线程执行的，如果在把日志文件写入磁盘，磁盘读写压力比较大，就会导致写磁盘很慢，进而导致后续的操作也无法进行

### 刷盘策略
* always: 同步写回，每个写命令执行完，立刻同步地将日志写回磁盘
* everysec：每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓存区，每隔一秒把缓存区的内容写入到磁盘
* no：操作系统控制的写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓存区，由操作系统决定何时将缓冲区内容写回磁盘

### 带来三个性能问题
* 文件系统本身对文件大小有限制，无法保存过大的文件
* 如果文件太大，之后再往里面追加命令记录的话，效率会变低
* 如果发生宕机，aof中记录的命令要一个个被重新执行，用于故障恢复，如果文件太大，整个恢复过程就会非常缓慢

### AOF重写
* 实际上，重写机制具有“多变一”的功能，所谓的“多变一”的功能，也就是旧日志文件中的多条命令，在重写后的新日志变成一条命令

### AOF 重写会阻塞吗?
* 和AOF日志由主线程写回不同，重写过程是由后台子进程bgrewriteaof来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。

###  什么时候会触发AOF 重写呢？
有两个配置项在控制AOF重写的触发时机：
1. auto-aof-rewrite-min-size: 表示运行AOF重写时文件的最小大小，默认为64MB
2. auto-aof-rewrite-percentage: 这个值的计算方法是：当前AOF文件大小和上一次重写后AOF文件大小的差值，再除以上一次重写后AOF文件大小。也就是当前AOF文件比上一次重写后AOF文件的增量大小，和上一次重写后AOF文件大小的比值。

AOF文件大小同时超出上面这两个配置项时，会触发AOF重写
  
### 问题1
* AOF 日志重写的时候，是由 bgrewriteaof 子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞风险呢？如果有的话，会在哪里阻塞？
#### 答案：
* fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程，老师文章写的是拷贝所有内存数据给子进程，我个人认为是有歧义的），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。

* fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。

### 问题1
*  AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？
#### 答案：
AOF重写不复用AOF本身的日志，一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可


## RDB

### 背景
* AOF进行故障恢复的时间，需要逐一把操作的日志都执行一遍，如果操作日志非常多，redis就会恢复的很缓慢

### 定义
* 全程 Redis DataBase
* redis提供了另外一种方式:内存快照，所谓的内存快照就是指内存中的数据在某一时刻的状态记录
* 对redis来说就是把某一时刻的状态以文件形式写入到磁盘上
  
### 关键问题
* 对哪些数据做快照？关系到快照执行效率的问题
  * redis的数据都在内存中，为了提高所有数据的可靠性，执行了全量的快照
  * redis提供了两个命令生成RDB文件，分别是save和bgsave
    * save是在主线程执行，会阻塞redis的主线程
    * bgsave是创建一个子线程，专门用于写入rdb文件，避免主线程的阻塞，这也是redis rdb文件生成的默认配置
* 做快照时候，数据还能被删改么？这个关系到redis是否被阻塞
  * redis就会借助操作系统提供的写时复制技术，在执行快照的同时，正常处理写操作
  * bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。
  * 如果主线程要修改一块数据，那么这块数据就会被复制一份，生成该数据的副本，然后主线程在这个数据副本上进行修改，同时，bgsave子进程可以继续把原来的数据写入rdb文件
* 频繁地执行全量快照，也会带来两方面的开线
  * 频繁将全量数据写入磁盘，会给磁盘带来很大的压力，多个快照竞争有限的磁盘带宽
  * bgsave子进程需要通过fork操作从主线程创建出来的，子进程创建过程中会阻塞主线程，而且主线程的内存越大，阻塞的时间越长
### 混合使用AOF+RDB
Redis 4.0 中提出了一个混合使用 AOF 日志和内存快照的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。

这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF 日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销

## 总结
* 我们一直说的redis高可用性，其实就是 1. 数据不丢失，2. 服务尽量不中断
  * aof和rdb保证了前者，后者增加副本冗余，将一份数据同时保存到多个实例上，一个实例出现故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。

## RDB和AOF的优缺点
### 文件大小
* RDB文件内容是经过压缩的二进制数据，文件很小
* AOF文件记录的每一次写操作的命令，写操作越多文件就会很大
* 在主从全量数据同步时，传输RDB文件可以尽量降低对主库机器网络带宽的消耗，从库在加载RDB文件时，一是文件小，读取整个文件的速度会很快，二是因为RDB文件存储的都是二进制数据，从库直接按照RDB协议解析还原数据即可，速度会非常快，而AOF需要依次重放每个写命令，这个过程会经历冗长的处理逻辑，恢复速度相比RDB会慢得多，所以使用RDB进行主从全量同步的成本最低
  
### 