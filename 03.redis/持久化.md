## AOF

### 流程
* 先执行命令，在记录AOF日志
* 命令执行后才记录日志，不会阻塞当前的写操作

### 风险
* 如果命令执行完，还没有来的及记录日志就宕机了，那么这个命令和相应的数据就丢失了
* AOF虽然避免了对当前命令的阻塞，可能会给下一个操作带来阻塞风险，因为,AOF日志也是主线程执行的，如果在把日志文件写入磁盘，磁盘读写压力比较大，就会导致写磁盘很慢，进而导致后续的操作也无法进行

### 刷盘策略
* always: 同步写回，每个写命令执行完，立刻同步地将日志写回磁盘
* everysec：每秒写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓存区，每隔一秒把缓存区的内容写入到磁盘
* no：操作系统控制的写回，每个写命令执行完，只是先把日志写到AOF文件的内存缓存区，由操作系统决定何时将缓冲区内容写回磁盘

### 带来三个性能问题
* 文件系统本身对文件大小有限制，无法保存过大的文件
* 如果文件太大，之后再往里面追加命令记录的话，效率会变低
* 如果发生宕机，aof中记录的命令要一个个被重新执行，用于故障恢复，如果文件太大，整个恢复过程就会非常缓慢

### AOF重写
* 实际上，重写机制具有“多变一”的功能，所谓的“多变一”的功能，也就是旧日志文件中的多条命令，在重写后的新日志变成一条命令

### AOF 重写会阻塞吗?
* 和AOF日志由主线程写回不同，重写过程是由后台子进程bgrewriteaof来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。
  
### 问题1
* AOF 日志重写的时候，是由 bgrewriteaof 子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞风险呢？如果有的话，会在哪里阻塞？
#### 答案：
* fork子进程，fork这个瞬间一定是会阻塞主线程的（注意，fork时并不会一次性拷贝所有内存数据给子进程，老师文章写的是拷贝所有内存数据给子进程，我个人认为是有歧义的），fork采用操作系统提供的写实复制(Copy On Write)机制，就是为了避免一次性拷贝大量内存数据给子进程造成的长时间阻塞问题，但fork子进程需要拷贝进程必要的数据结构，其中有一项就是拷贝内存页表（虚拟内存和物理内存的映射索引表），这个拷贝过程会消耗大量CPU资源，拷贝完成之前整个进程是会阻塞的，阻塞时间取决于整个实例的内存大小，实例越大，内存页表越大，fork阻塞时间越久。拷贝内存页表完成后，子进程与父进程指向相同的内存地址空间，也就是说此时虽然产生了子进程，但是并没有申请与父进程相同的内存大小。那什么时候父子进程才会真正内存分离呢？“写实复制”顾名思义，就是在写发生时，才真正拷贝内存真正的数据，这个过程中，父进程也可能会产生阻塞的风险，就是下面介绍的场景。

* fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。但是此时父进程依旧是会有流量写入的，如果父进程操作的是一个已经存在的key，那么这个时候父进程就会真正拷贝这个key对应的内存数据，申请新的内存空间，这样逐渐地，父子进程内存数据开始分离，父子进程逐渐拥有各自独立的内存空间。因为内存分配是以页为单位进行分配的，默认4k，如果父进程此时操作的是一个bigkey，重新申请大块内存耗时会变长，可能会产阻塞风险。另外，如果操作系统开启了内存大页机制(Huge Page，页面大小2M)，那么父进程申请内存时阻塞的概率将会大大提高，所以在Redis机器上需要关闭Huge Page机制。Redis每次fork生成RDB或AOF重写完成后，都可以在Redis log中看到父进程重新申请了多大的内存空间。

### 问题1
*  AOF 重写也有一个重写日志，为什么它不共享使用 AOF 本身的日志呢？
#### 答案：
AOF重写不复用AOF本身的日志，一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。所以Redis AOF重写一个新文件，重写失败的话，直接删除这个文件就好了，不会对原先的AOF文件产生影响。等重写完成之后，直接替换旧文件即可