# 内存结构
* bufferPool
* change buffer
* adaptive hash index
* log bugger

## Buffer Pool
### 概述
缓冲池是主内存中的一个区域，在InnoDB访问表和索引数据时缓存这些数据。缓冲池允许经常使用的数据直接从内存中访问，从而加快处理速度。在专用服务器上，通常将物理内存的高达80％分配给缓冲池。
为了提高大容量读取操作的效率，缓冲池被分成可能包含多行的页面。为了缓存管理的效率，缓冲池被实现为页面链表；很少使用的数据使用最近最少使用 (LRU) 算法的变体从缓存中老化。
知道如何利用缓冲池将频繁访问的数据保存在内存中是 MySQL 调优的一个重要方面。

知道如何利用缓冲池将频繁访问的数据保存在内存中是 MySQL 调优的一个重要方面。



### 缓冲池LRU算法

缓冲池使用 LRU 算法的变体作为列表进行管理。当需要空间将新页面添加到缓冲池时，最近最少使用的页面将被逐出，并将新页面添加到列表的中间。这种中点插入策略将列表视为两个子列表：
* 在头部，最近访问的新页面的子列表
* 在尾部，最近较少访问的旧页面的子列表
  ![Alt text](image/innodb-buffer-pool-list.png)

* 该算法将经常使用的页面保留在新的子列表中。旧的子列表包含不常用的页面；这些页面是驱逐的候选者。

默认情况下，算法运行如下：
1. 缓冲池的 3/8 专门用于旧子列表。
2. 列表的中点是新子列表的尾部与旧子列表的头部相交。
3. 当InnoDB将一个页面读入缓冲池时，它最初会将其插入到中点（旧子列表的头部）。页面可以被读取，因为它是用户发起操作（如SQL查询）所需，或作为由InnoDB自动执行的预读操作的一部分。
4. 随着数据库的运行，缓冲池中未访问的页面通过向列表的尾部移动而“老化”。随着其他页面的更新，新旧子列表中的页面都会老化。随着在中点插入页面，旧子列表中的页面也会老化。最终，未使用的页面到达旧子列表的尾部并被逐出。


默认情况下，查询读取的页面会立即移动到新的子列表中，这意味着它们在缓冲池中停留的时间更长。例如，为 mysqldump 操作或不带 WHERE 子句的 SELECT 语句执行的表扫描可以将大量数据带入缓冲池并驱逐等量的旧数据，即使新数据永远不会再使用。同样，由预读后台线程加载且仅访问一次的页面将移至新列表的头部。这些情况可以将经常使用的页面推送到旧的子列表，在那里它们会被驱逐。


InnoDB 标准监视器输出包含 BUFFER POOL AND MEMORY 部分中有关缓冲池 LRU 算法操作的几个字段。有关详细信息，请参阅使用 InnoDB 标准监视器监视缓冲池。

### 缓冲池配置
* 您可以配置缓冲池的各个方面以提高性能
  * 理想情况下，您将缓冲池的大小设置为尽可能大的值，为服务器上的其他进程留出足够的内存来运行而无需过多的分页。缓冲池越大， InnoDB 就越像内存数据库，从磁盘读取一次数据，然后在后续读取期间从内存访问数据。
  * 在具有足够内存的 64 位系统上，您可以将缓冲池拆分为多个部分，以最大程度地减少并发操作之间对内存结构的争用。有关详细信息，请参阅第 15.8.3.2 节，“配置多个缓冲池实例”。
  * 您可以将经常访问的数据保留在内存中，而不管来自将大量不经常访问的数据带入缓冲池的操作的活动突然激增。有关详细信息，请参阅第 15.8.3.3 节，“使缓冲池具有抗扫描性”。
  * 您可以控制如何以及何时执行预读请求以异步将页面预取到缓冲池中，以应对即将发生的需求。
  * 您可以控制何时发生后台刷新以及是否根据工作负载动态调整刷新率。有关详细信息，
  * 您可以配置 InnoDB 保留当前缓冲池状态的方式，以避免在服务器重启后出现冗长的预热期

### 使用 InnoDB 标准监视器监视缓冲池
* InnoDB 标准监视器输出，可以使用 SHOW ENGINE INNODB STATUS 访问，提供有关缓冲池操作的指标，缓冲池指标位于 InnoDB 标准监视器输出的 BUFFER POOL AND MEMORY 部分：
  
```
----------------------
BUFFER POOL AND MEMORY
----------------------
Total large memory allocated 2198863872
Dictionary memory allocated 776332
Buffer pool size   131072
Free buffers       124908
Database pages     5720
Old database pages 2071
Modified db pages  910
Pending reads 0
Pending writes: LRU 0, flush list 0, single page 0
Pages made young 4, not young 0
0.10 youngs/s, 0.00 non-youngs/s
Pages read 197, created 5523, written 5060
0.00 reads/s, 190.89 creates/s, 244.94 writes/s
Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not
0 / 1000
Pages read ahead 0.00/s, evicted without access 0.00/s, Random read
ahead 0.00/s
LRU len: 5720, unzip_LRU len: 0
I/O sum[0]:cur[0], unzip sum[0]:cur[0]
```

###  InnoDB 缓冲池指标
|Name|	Description|
|---|---|
|分配的总内存|	为缓冲池分配的总内存（以字节为单位）。|
|Dictionary memory allocated 字典内存分配	|为 InnoDB 数据字典分配的总内存（以字节为单位）。|
 |缓冲池大小	|分配给缓冲池的页面总大小。
|Free buffers |	缓冲池空闲列表的页面总大小。
|Database pages	|缓冲池 LRU 列表的页面总大小。
| 旧数据库页面|缓冲池旧 LRU 子列表的页面总大小。|
| 修改后的数据库页面	|当前在缓冲池中修改的页数。|
|Pending reads	|等待读入缓冲池的缓冲池页数。|
| 挂起写 LRU|	从 LRU 列表底部开始写入缓冲池中旧脏页的数量。|
 |挂起写入刷新列表|	检查点期间要刷新的缓冲池页面数。|
|挂起写单页	|缓冲池中待处理的独立页面写入数。|
|页面变得年轻	|缓冲池 LRU 列表中年轻的页面总数（移动到“新”页面子列表的头部）。|
 |页面制作不年轻|	缓冲池 LRU 列表中未变为年轻的页面总数（保留在“旧”子列表中但未变为年轻的页面）。|
|youngs/s|	每秒平均访问缓冲池 LRU 列表中导致页面年轻的旧页面。有关详细信息，请参阅此表后面的注释。|
|non-youngs/s|	每秒平均访问缓冲池 LRU 列表中的旧页面，导致页面不年轻。|
|Pages read|	从缓冲池中读取的总页数。|
|Pages created|	在缓冲池中创建的页面总数。|
|Pages written	|从缓冲池中写入的总页数。
|reads/s	|每秒平均读取缓冲池页数。|
|creates/s|	每秒创建的缓冲池页的平均数。|
|writes/s|	每秒平均写入缓冲池页数。|
|Buffer pool hit rate 缓冲池命中率|	从缓冲池读取页面与从磁盘存储读取页面的缓冲池页面命中率。|
|young-making rate|	页面访问导致页面年轻化的平均命中率。有关详细信息，请参阅此表后面的注释。|
| 不是（年轻化率）|页面访问未导致页面年轻化的平均命中率。有关详细信息，请参阅此表后面的注释。|
 |预读页面|	预读操作的每秒平均值。|
 |无法访问的页面被逐出|	没有从缓冲池中访问而被逐出的页面的每秒平均值。|
|随机预读	|随机预读操作的每秒平均值。|
|LRU len|缓冲池 LRU 列表的页面总大小。|
|unzip_LRU len|	缓冲池 unzip_LRU 列表的长度（以页为单位）。|
|I/O sum|	访问的缓冲池 LRU 列表页总数。|
|I/O cur|	当前时间间隔内访问的缓冲池 LRU 列表页总数。|
|I/O解压缩总和	|.解压缩的缓冲池 unzip_LRU 列表页总数。|
| I/O 解压缩	|当前时间间隔内解压缩的缓冲池 unzip_LRU 列表页总数。|

#### 说明
* youngs/s 指标仅适用于旧页面。它基于页面访问次数。给定页面可以有多次访问，所有这些都被计算在内。如果在没有发生大型扫描时看到非常低的 youngs/s 值，请考虑减少延迟时间或增加用于旧子列表的缓冲池的百分比。增加百分比会使旧的子列表变大，从而使该子列表中的页面移动到尾部的时间更长，从而增加了再次访问这些页面并使其成为年轻页面的可能性


## Change Buffer
### 概述
更改缓冲区是一种特殊的数据结构，当这些页面不在缓冲池中时，它会缓存对二级索引页面的更改。缓冲的更改可能由 INSERT 、 UPDATE 或 DELETE 操作 (DML) 引起，稍后当其他读取操作将页面加载到缓冲池中时，这些更改将被合并。
![Alt text](https://dev.mysql.com/doc/refman/8.0/en/images/innodb-change-buffer.png)

* 与聚集索引不同，二级索引通常是非唯一的，并且以相对随机的顺序插入二级索引。同样，删除和更新可能会影响索引树中不相邻的二级索引页。当其他操作将受影响的页面读入缓冲池时，稍后合并缓存的更改可避免将二级索引页面从磁盘读入缓冲池所需的大量随机访问 I/O。
* 在系统大部分空闲时或缓慢关闭期间运行的清除操作会定期将更新的索引页写入磁盘。与立即将每个值写入磁盘相比，清除操作可以更有效地为一系列索引值写入磁盘块。
* 当有许多受影响的行和许多二级索引要更新时，更改缓冲区合并可能需要几个小时。在此期间，磁盘 I/O 增加，这可能会导致磁盘绑定查询显着减慢。更改缓冲区合并也可能在提交事务后继续发生，甚至在服务器关闭并重新启动后。

在内存中，变化缓冲区占据缓冲池的一部分。在磁盘上，更改缓冲区是系统表空间的一部分，当数据库服务器关闭时，索引更改将被缓冲。
更改缓冲区中缓存的数据类型由 innodb_change_buffering 变量控制。有关详细信息，请参阅配置更改缓冲。您还可以配置最大更改缓冲区大小。有关详细信息，请参阅配置更改缓冲区的最大大小。

## 配置更改缓冲
* 当对表执行 INSERT 、 UPDATE 和 DELETE 操作时，索引列的值（尤其是二级键的值）通常处于未排序的顺序，需要大量的 I/O 来启动二级索引迄今为止。

* 当相关页面不在缓冲池中时，更改缓冲区缓存对二级索引条目的更改，从而通过不立即从磁盘读取页面来避免昂贵的 I/O 操作。当页面加载到缓冲池中时，缓冲的更改被合并，更新后的页面稍后刷新到磁盘。 InnoDB 主线程在服务器几乎空闲时和缓慢关闭期间合并缓冲的更改。
* 因为它可以减少磁盘读写，所以更改缓冲对于受 I/O 限制的工作负载最有价值；例如，具有大量 DML 操作（如批量插入）的应用程序受益于更改缓冲。
* 但是，更改缓冲区占用了缓冲池的一部分，减少了可用于缓存数据页的内存。如果工作集几乎适合缓冲池，或者如果您的表的二级索引相对较少，则禁用更改缓冲可能会有用。如果工作数据集完全适合缓冲池，则更改缓冲不会造成额外开销，因为它仅适用于不在缓冲池中的页面。
* innodb_change_buffering 变量控制 InnoDB 执行更改缓冲的程度。您可以为插入、删除操作（当索引记录最初被标记为删除时）和清除操作（当索引记录被物理删除时）启用或禁用缓冲。更新操作是插入和删除的组合。默认的 innodb_change_buffering 值为 all，允许的 innodb_change_buffering 值包括：
  * 默认值：缓冲区插入、删除标记操作和清除。
  * 不要缓冲任何操作。
  * 缓冲区插入操作。
  * 缓冲区删除标记操作。
  * 缓冲插入和删除标记操作。
  * 缓冲在后台发生的物理删除操作。


## 配置更改缓冲区最大大小
* innodb_change_buffer_max_size 变量允许将更改缓冲区的最大大小配置为缓冲池总大小的百分比。默认情况下， innodb_change_buffer_max_size 设置为 25。最大设置为 50。
* 考虑在具有大量插入、更新和删除活动的 MySQL 服务器上增加 innodb_change_buffer_max_size ，其中更改缓冲区合并跟不上新的更改缓冲区条目，导致更改缓冲区达到其最大大小限制。
* 考虑在用于报表的静态数据的MySQL服务器上减少innodb_change_buffer_max_size，或者如果更改缓冲区消耗了与缓冲池共享的内存空间太多，导致页面比预期更早地从缓冲池中过期。
* 考虑在用于报告的静态数据的MySQL服务器上减少innodb_change_buffer_max_size，或者如果更改缓冲区消耗了与缓冲池共享的内存空间太多，导致页面比预期更早地从缓冲池中过期。

## 监控更改缓冲区
以下选项可用于更改缓冲区监视：
* InnoDB 标准监视器输出包括更改缓冲区状态信息。要查看监视器数据，请发出 SHOW ENGINE INNODB STATUS 语句。

```
mysql> SHOW ENGINE INNODB STATUS\G

```
* 更改缓冲区状态信息位于 INSERT BUFFER AND ADAPTIVE HASH INDEX 标题下，类似于以下内容
```
-------------------------------------
INSERT BUFFER AND ADAPTIVE HASH INDEX
-------------------------------------
Ibuf: size 1, free list len 0, seg size 2, 0 merges
merged operations:
 insert 0, delete mark 0, delete 0
discarded operations:
 insert 0, delete mark 0, delete 0
Hash table size 4425293, used cells 32, node heap has 1 buffer(s)
13577.57 hash searches/s, 202.47 non-hash searches/s
```

## 自适应哈希索引
### 定义
* 自适应哈希索引使 InnoDB 能够在具有适当的工作负载组合和足够的缓冲池内存的系统上执行更像内存数据库，而不会牺牲事务功能或可靠性。
* 基于观察到的搜索模式，使用索引键的前缀构建哈希索引。前缀可以是任意长度，也可能只是B树中的某些值出现在哈希索引中。哈希索引是针对经常访问的索引页面按需构建的。
* 如果一个表几乎完全适合主内存，哈希索引可以通过启用任何元素的直接查找来加速查询，将索引值转换为指针。InnoDB具有监视索引搜索的机制。如果InnoDB注意到查询可以从构建哈希索引中受益，则会自动执行此操作。
* 对于某些工作负载，哈希索引查找的加速大大超过了监视索引查找和维护哈希索引结构的额外工作。在繁重的工作负载（例如多个并发连接）下，访问自适应哈希索引有时会成为争用的源头。使用 LIKE 运算符和 % 通配符的查询也往往不会受益。对于无法从自适应哈希索引中获益的工作负载，将其关闭可减少不必要的性能开销。由于很难提前预测自适应哈希索引是否适合特定系统和工作负载，因此请考虑在启用和禁用它的情况下运行基准测试。

*  可以在 SHOW ENGINE INNODB STATUS 输出的 SEMAPHORES 部分监视自适应散列索引的使用和争用。如果有大量线程等待在 btr0sea.c 中创建的 rw-latches，请考虑增加自适应哈希索引分区的数量或禁用自适应哈希索引。

## 日志缓冲区
### 定义
日志缓冲区是存储要写入磁盘上日志文件的数据的内存区域。日志缓冲区大小由 innodb_log_buffer_size 变量定义。默认大小为 16MB。日志缓冲区的内容会定期刷新到磁盘。大型日志缓冲区使大型事务无需在事务提交之前将重做日志数据写入磁盘即可运行。因此，如果您有更新、插入或删除许多行的事务，增加日志缓冲区的大小可以节省磁盘 I/O。